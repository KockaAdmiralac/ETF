%{
    #include <cstdio>
    #include <iostream>
    #include <vector>
    #include "inc/syntax.hpp"

    extern int yylex();
    extern int yyparse();
    extern void yylex_destroy();
    extern FILE *yyin;
    extern int lineNumber;
 
    void yyerror(std::vector<Line>& lines, const char *s);

%}
%union {
    int reg;
    int num;
    char* sym;
    char* label;
    char* str;
    SymbolList symList;
    Operand operand;
    Directive directive;
    Instruction instruction;
}
%token PLUS
%token STAR
%token DOLLAR
%token LBRACKET
%token RBRACKET
%token PERCENT
%token COMMA
%token COMMENT
%token ENDL
%token DIRECTIVE_GLOBAL
%token DIRECTIVE_EXTERN
%token DIRECTIVE_SECTION
%token DIRECTIVE_WORD
%token DIRECTIVE_SKIP
%token DIRECTIVE_ASCII
%token DIRECTIVE_EQU
%token DIRECTIVE_END
%token INSTRUCTION_HALT
%token INSTRUCTION_INT
%token INSTRUCTION_IRET
%token INSTRUCTION_CALL
%token INSTRUCTION_RET
%token INSTRUCTION_JMP
%token INSTRUCTION_JEQ
%token INSTRUCTION_JNE
%token INSTRUCTION_JGT
%token INSTRUCTION_PUSH
%token INSTRUCTION_POP
%token INSTRUCTION_XCHG
%token INSTRUCTION_ADD
%token INSTRUCTION_SUB
%token INSTRUCTION_MUL
%token INSTRUCTION_DIV
%token INSTRUCTION_CMP
%token INSTRUCTION_NOT
%token INSTRUCTION_AND
%token INSTRUCTION_OR
%token INSTRUCTION_XOR
%token INSTRUCTION_TEST
%token INSTRUCTION_SHL
%token INSTRUCTION_SHR
%token INSTRUCTION_LDR
%token INSTRUCTION_STR
%token <reg> REG
%token <num> NUM
%token <sym> SYM
%token <str> STRING
%token <label> LABEL
%type <operand> operand_data
%type <operand> operand_addr
%type <directive> directive
%type <instruction> instruction
%type <symList> syms
%parse-param {std::vector<Line>& lines}
%%
lines: lines line | line;
line:
      LABEL ENDL                                { Line l; l.type = L_INS; l.data.ins.type = INS_NONE; l.label = $1; lines.push_back(l);     }
    | LABEL instruction ENDL                    { Line l; l.type = L_INS; l.label = $1; l.data.ins = $2; lines.push_back(l);                }
    | LABEL directive ENDL                      { Line l; l.type = L_DIR; l.label = $1; l.data.dir = $2; lines.push_back(l);                }
    | LABEL instruction COMMENT ENDL            { Line l; l.type = L_INS; l.label = $1; l.data.ins = $2; lines.push_back(l);                }
    | LABEL directive COMMENT ENDL              { Line l; l.type = L_DIR; l.label = $1; l.data.dir = $2; lines.push_back(l);                }
    | LABEL COMMENT ENDL                        { Line l; l.type = L_INS; l.label = $1; l.data.ins.type = INS_NONE; lines.push_back(l);     }
    | instruction ENDL                          { Line l; l.type = L_INS; l.label = nullptr; l.data.ins = $1; lines.push_back(l);           }
    | directive ENDL                            { Line l; l.type = L_DIR; l.label = nullptr; l.data.dir = $1; lines.push_back(l);           }
    | instruction COMMENT ENDL                  { Line l; l.type = L_INS; l.label = nullptr; l.data.ins = $1; lines.push_back(l);           }
    | directive COMMENT ENDL                    { Line l; l.type = L_DIR; l.label = nullptr; l.data.dir = $1; lines.push_back(l);           }
    | COMMENT ENDL                              ;
    | ENDL                                      ;
    ;
directive:
      DIRECTIVE_GLOBAL syms                     { $$.type = DIR_GLOBAL; $$.syms = $2;               }
    | DIRECTIVE_EXTERN syms                     { $$.type = DIR_EXTERN; $$.syms = $2;               }
    | DIRECTIVE_SECTION SYM                     { $$.type = DIR_SECTION; $$.sym = $2;               }
    | DIRECTIVE_WORD NUM                        { $$.type = DIR_WORD; $$.num = $2;                  }
    | DIRECTIVE_WORD syms                       { $$.type = DIR_WORD; $$.syms = $2;                 }
    | DIRECTIVE_SKIP NUM                        { $$.type = DIR_SKIP; $$.num = $2;                  }
    | DIRECTIVE_ASCII STRING                    { $$.type = DIR_ASCII; $$.sym = $2;                 }
    | DIRECTIVE_EQU SYM COMMA SYM               { $$.type = DIR_EQU; $$.sym = $2; $$.sym2 = $4;     }
    | DIRECTIVE_END                             { $$.type = DIR_END;                                }
    ;
instruction:
      INSTRUCTION_HALT                          { $$.type = INS_HALT;                               }
    | INSTRUCTION_INT REG                       { $$.type = INS_INT; $$.reg1 = $2;                  }
    | INSTRUCTION_IRET                          { $$.type = INS_IRET;                               }
    | INSTRUCTION_CALL operand_addr             { $$.type = INS_CALL; $$.operand = $2;              }
    | INSTRUCTION_RET                           { $$.type = INS_RET;                                }
    | INSTRUCTION_JMP operand_addr              { $$.type = INS_JMP; $$.operand = $2;               }
    | INSTRUCTION_JEQ operand_addr              { $$.type = INS_JEQ; $$.operand = $2;               }
    | INSTRUCTION_JNE operand_addr              { $$.type = INS_JNE; $$.operand = $2;               }
    | INSTRUCTION_JGT operand_addr              { $$.type = INS_JGT; $$.operand = $2;               }
    | INSTRUCTION_PUSH operand_addr             { $$.type = INS_PUSH; $$.operand = $2;              }
    | INSTRUCTION_POP REG                       { $$.type = INS_POP; $$.reg1 = $2;                  }
    | INSTRUCTION_XCHG REG COMMA REG            { $$.type = INS_XCHG; $$.reg1 = $2; $$.reg2 = $4;   }
    | INSTRUCTION_ADD REG COMMA REG             { $$.type = INS_ADD; $$.reg1 = $2; $$.reg2 = $4;    }
    | INSTRUCTION_SUB REG COMMA REG             { $$.type = INS_SUB; $$.reg1 = $2; $$.reg2 = $4;    }
    | INSTRUCTION_MUL REG COMMA REG             { $$.type = INS_MUL; $$.reg1 = $2; $$.reg2 = $4;    }
    | INSTRUCTION_DIV REG COMMA REG             { $$.type = INS_DIV; $$.reg1 = $2; $$.reg2 = $4;    }
    | INSTRUCTION_CMP REG COMMA REG             { $$.type = INS_CMP; $$.reg1 = $2; $$.reg2 = $4;    }
    | INSTRUCTION_NOT REG                       { $$.type = INS_NOT; $$.reg1 = $2;                  }
    | INSTRUCTION_AND REG COMMA REG             { $$.type = INS_AND; $$.reg1 = $2; $$.reg2 = $4;    }
    | INSTRUCTION_OR REG COMMA REG              { $$.type = INS_OR; $$.reg1 = $2; $$.reg2 = $4;     }
    | INSTRUCTION_XOR REG COMMA REG             { $$.type = INS_XOR; $$.reg1 = $2; $$.reg2 = $4;    }
    | INSTRUCTION_TEST REG COMMA REG            { $$.type = INS_TEST; $$.reg1 = $2; $$.reg2 = $4;   }
    | INSTRUCTION_SHL REG COMMA REG             { $$.type = INS_SHL; $$.reg1 = $2; $$.reg2 = $4;    }
    | INSTRUCTION_SHR REG COMMA REG             { $$.type = INS_SHR; $$.reg1 = $2; $$.reg2 = $4;    }
    | INSTRUCTION_LDR REG COMMA operand_data    { $$.type = INS_LDR; $$.reg1 = $2; $$.operand = $4; }
    | INSTRUCTION_STR REG COMMA operand_data    { $$.type = INS_STR; $$.reg1 = $2; $$.operand = $4; }
    ;
operand_data:
      DOLLAR NUM                            { $$.type = OP_DOLLAR_LITERAL; $$.num = $2;                                 }
    | DOLLAR SYM                            { $$.type = OP_DOLLAR_SYMBOL; $$.sym = $2;                                  }
    | PERCENT SYM                           { $$.type = OP_PERCENT_SYMBOL; $$.sym = $2;                                 }
    | LBRACKET REG RBRACKET                 { $$.type = OP_BRACKET_REGISTER; $$.reg = $2;                               }
    | LBRACKET REG PLUS NUM RBRACKET        { $$.type = OP_BRACKET_REGISTER_LITERAL; $$.reg = $2; $$.num = $4;          }
    | LBRACKET REG PLUS SYM RBRACKET        { $$.type = OP_BRACKET_REGISTER_SYMBOL; $$.reg = $2; $$.sym = $4;           }
    | SYM                                   { $$.type = OP_SYMBOL; $$.sym = $1;                                         }
    | NUM                                   { $$.type = OP_LITERAL; $$.num = $1;                                        }
    | REG                                   { $$.type = OP_REGISTER; $$.reg = $1;                                       }
    ;
operand_addr:
      PERCENT SYM                           { $$.type = OP_PERCENT_SYMBOL; $$.sym = $2;                                 }
    | STAR NUM                              { $$.type = OP_STAR_LITERAL; $$.num = $2;                                   }
    | STAR SYM                              { $$.type = OP_STAR_SYMBOL; $$.sym = $2;                                    }
    | STAR REG                              { $$.type = OP_STAR_REGISTER; $$.reg = $2;                                  }
    | STAR LBRACKET REG RBRACKET            { $$.type = OP_STAR_BRACKET_REGISTER; $$.reg = $3;                          }
    | STAR LBRACKET REG PLUS NUM RBRACKET   { $$.type = OP_STAR_BRACKET_REGISTER_LITERAL; $$.reg = $3; $$.num = $5;     }
    | STAR LBRACKET REG PLUS SYM RBRACKET   { $$.type = OP_STAR_BRACKET_REGISTER_SYMBOL; $$.reg = $3; $$.sym = $5;      }
    | SYM                                   { $$.type = OP_SYMBOL; $$.sym = $1;                                         }
    | NUM                                   { $$.type = OP_LITERAL; $$.num = $1;                                        }
    ;
syms:
      syms COMMA SYM {
          $$.length = $1.length + 1;
          $$.syms = (char**)realloc($1.syms, $$.length * sizeof(char*));
          if ($$.syms == NULL) {
              free($1.syms);
              YYNOMEM;
          }
          $$.syms[$$.length - 1] = $3;
      }
    | SYM {
          $$.length = 1;
          $$.syms = (char**)malloc(1 * sizeof(char*));
          $$.syms[0] = $1;
      }
    ;
%%
#ifdef DEBUG_SYNTAX
int main(int argc, char *argv[]) {
    if (argc <= 1) {
        std::cout << "Invalid number of arguments" << std::endl;
        return -1;
    }
    FILE *file = fopen(argv[1], "r");
    if (!file) {
        std::cout << "Invalid file" << std::endl;
        return -1;
    }
    yyin = file;
    std::vector<Line> lines;
    int parseRet = yyparse(lines);
    yylex_destroy();
    fclose(file);
    switch (parseRet) {
        case 0:
            std::cout << "Number of lines: " << lines.size() << std::endl;
            for (Line& line : lines) {
                std::cout << line.type << std::endl;
            }
            break;
        case 1:
            std::cout << "Stopping due to parse errors." << std::endl;
            break;
        case 2:
            std::cout << "Stopping due to memory exhaustion during parsing." << std::endl;
            break;
        default:
            std::cout << "Unknown parser error, error code: " << parseRet;
            break;
    }
}

void yyerror(std::vector<Line>& lines, const char *s) {
    std::cout << "Parse error on line " << lineNumber << ", after instruction " << lines.size() << ": " << s << std::endl;
}
#endif
