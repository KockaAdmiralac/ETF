## Napredne tehnike keš optimizacije
- Tehnike:
    - Hit time:
        - Small and simple first-level caches
        - Way prediction: Predvidi iz koje banke će da se servira podatak ili instrukcija
    - Bandwidth:
        - Pipelined caches: ?
        - Multibanked caches: Više banki keša, kao memory interleaving samo umesto jednog podatka iz više banki se različitim bankama zadaju različiti podaci
        - Non-blocking caches: dozvoli dovlačenje nekog drugog podatka dok operativna memorija odgovara za neki prethodni
    - Miss penalty:
        - Critical word first: prvo vrati onu reč koja je tražena iz memorije a zatim dovlači ostatak bloka
        - Merging write buffers: Kada izbacujemo podatak iz keša on se izbaci iz write buffer, a mi možemo da čekamo da nam se napuni write buffer pa da ga upišemo
            - Ovo ima probleme sa konkurentnim programima i IO
    - Miss rate:
        - Compiler optimizations:
            - Merging arrays: umesto dva niza kompajler napravi niz struktura, ili obrnuto
            - Loop interchange: ako smo zeznuli redosled pristupa matrici kompajler to može da popravi
            - Loop fusion: ako dve (nezavisne!) petlje zaredom obilaze istu strukturu on može da ih spoji
            - Blocking: podeli matricu nad kojom se radi na blokove tako da ti odgovarajući broj blokova stane u keš memoriju
    - Paralelizacija:
        - Hardware prefetching: keš može da vidi kako mi redom pristupamo blokovima pa dovuče i sledeće blokove
        - Software prefetching: kompajler može ovo gore da uradi
            - U onom njegovom primeru poslednji prefetch radi izbacivanje i zato ne možemo da radimo prefetch b
    - HBM: High-Bandwidth Memory
        - Naslažu više slojeva peska kako bi dobili više memorije
        - Problem: manji blokovi zahtevaju više mesta za čuvanje tagova
        - Loh-Hill (L-H) keš
        - Alloy cache: čuvamo tagove u odvojenoj keš memoriji
            - Pošto nam je set-asocijativnost 29 možemo da ubacimo direktno mapiranje negde?
            - Memory Access Predictor
- Algoritmi zamene:
    - Približni LRU:
        - Zamena na osnovu jednog bita
            - Prvo biramo na osnovu jednog bita a kasnije nasumično, ili obrnuto
            - Složenost: ~~1~~NB? + log2(SA) - 1
            - 5-10% gori od LRU
        - Most Recently Used
            - Postavlja bit na 1 kad se pristupi, resetuje sve kad svi postanu 1
            - Složenost: NB * SA
            - 1% bolji do 3% gori
        - Modifikacija i486
            - Umesto poslednjeg se čuva pretposlednji pristup
            - Složenost: NB * SA
        - SIDE
            - Hit: postavimo brojač desno od mesta pogotka, ako je mesto pogotka desno
            - Miss: zamenimo na mestu brojača i inkrementiramo
            - 0-5% gori za malu asocijativnost
    - Bolji od LRU (ali teoretski):
        - 2Q: Tri reda, A1in (jedan pogodak, zaštićen, FIFO), A1out (jedan pogodak, nezaštićen, FIFO), An (više pogodaka, LRU)
            - Hit An: update LRU
            - Hit A1in: zameni blok iz An i A1in, update LRU, update FIFOin
            - Hit A1out: A1out -> An -> A1in -> A1out, update LRU, update FIFOin, update FIFOout
            - Miss: podatak -> A1in -> A1out -> izbacivanje, update FIFOin, update FIFOout
        - LRU-K: K šift registara, izbacujemo onog sa najmanje kečeva ili najdaljim kecom
        - SLRU: zaštićen i moguć segment, oba po LRU
        - ARC (Adaptive Replacement Cache):
            - Dva reda (L1 i L2) sa dva segmenta (Top i Bottom)
            - ||L1|| = ||L2|| = ||T1 + T2|| = c
            - Podešava se parametar p kojim se određuje dužina T1
            - Prioritet: T2 > B2 > T1 > B1

## Operativna memorija


## Virtuelizacija
- Nivoi privilegija:
    - x86 podržava četiri režima, koriste se samo 0 i 3
    - Call gates: strukture u zaštićenom segmentu memorije koje ograničavaju prelazak između režima (`lcall`)
    - Svaki nivo ima svoj stek (sigurnosni razlozi)
    - Tabele deskriptora: čuvaju informacije o pozvanim procedurama i TSS pokazivač
    - Task state segment: čuva pokazivače na novi stek nakon lcall (jer se ne čuvaju u deskriptorima), na njega pokazuje task register
    - Globalna tabela deskriptora sadrži deskriptore memorijskih segmenata, TSS, call gate ili lokalnih tabela deskriptora
- Virtuelizacija procesora:
    - Trap and Emulate problem: neke instrukcije se različito izvršavaju u različitim režimima
    - Binarno prevođenje: VMM proverava instrukcije i prevodi ih u nove
        - Vrlo sporo bez keširanja
- Virtuelizacija memorije:
    - Shadow Page Table: Tabela stranica koju VMM podmeće gostu
    - Problem: promene u tabelama stranica ne generišu prekid
        - Rešenje 1: označiti stranice gosta samo za čitanje
        - Rešenje 2: kada gost doda prevod koji generiše page fault VMM ažurira svoju tabelu, kada gost ukloni prevod VMM presretne INVLPG
        - Rešenje 3: paravirtuelizacija
- Proširenja arhitekture:
    - VT-x i AMD-V
    - VMCB: Stanje i informacije o instrukcijama i događajima za presretanje
    - Presretanjem vmrun se omogućava gnežđenje virtuelnih mašina

## Translacija instrukcija
- CISC vs. RISC:
    - RISC izvršavanje traje jedan takt
    - RISC ima ožičenu realizaciju
    - RISC je load/store
    - RISC nema mnogo načina adresiranja
    - RISC instrukcije su fiksne dužine
    - RISC ima mnogo registara
- Decode faza:
    - Jednostavni i složeni dekoderi
    - Mogu da rade u paraleli
- Pre-decode faza:
    - Obeležavaju se granice između instrukcija
    - Preskače se ukoliko su već prevedene:
        - Keš mikrooperacija
        - Trace keš
- Makrooperacije:
    - Atomične su
    - Intel: to su samo instrukcije
    - AMD: pojednostavljene instrukcije fiksne dužine, ili instrukcije koje su prošle niz transformacija
        - Mogu imati jednu aritmetičku operaciju i jednu load, store ili load+store operaciju na istu adresu
    - ARM: ne koristi eksplicitno, ali su to složene instrukcije koje se razlažu na jednostavnije
- Spajanje i razdvajanje:
    - Fetch, Decode, Queue, Scheduling, Dispatch, Execute
    - U Queue fazi mogu se spajati mikroinstrukcije
        - Čitanje iz memorije (odvojene mikroinstrukcije za izračunavanje adrese i prenos podataka)
        - Čitanje i modifikovanje
        - Read-modify-write
    - U Dispatch fazi mogu se razdvajati mikroinstrukcije ukoliko je to potrebno
    - Loop Stream Detector: kad detektuje petlju, nema potrebe za ponovnim dekodovanjem i čitanjem
    - U Queue fazi se takođe mogu razdvajati mikroinstrukcije:
        - Na primer, kod bazno-indeksnog adresiranja
        - Ovo se radi ukoliko žele da se uštedi na broju tranzistora i potrošnji struje
    - Makrooperacije takođe mogu da se spajaju (u Decode fazi):
        - Poboljšana ALU (EALU)
        - CMP+JMP

## SIMD
- Prednosti SIMD:
    - Manje instrukcija za više posla
    - Iskorišćava paralelizam na nivou podataka na najbolji način
    - Energetski efikasniji
- Optimizacije:
    - Multiple Lanes: više lejnova u paraleli obrađuju podatke nad kojima SIMD instrukcija radi
    - Vector Length Registers: određuje koliko elemenata zapravo ima u vektorskom registru
        - Ako prekoračava dužinu niza možemo u prvoj ili poslednjoj iteraciji da postavimo VLR
    - Vector Mask Registers: označava nad kojim podacima se radi operacija
        - Možemo zameniti if-else sa ovim
    - Memory Banks: treba nam dovoljno banki kako bismo u tokom izvršavanja SIMD instrukcije mogli da sve informacije primimo takt za taktom
    - Stride: možemo da preskačemo elemente niza koje dohvatamo u registar
        - Ovo može da nas zajebe ako gađamo svi istu banku
    - Scatter-Gather: na osnovu maske se elementi niza spakuju u vektorski registar
    - Programming Vector Architectures: kompajleri autovektorizuju kad mogu, ali najbolje kad to programeri sami rade
- Vreme izvršavanja zavisi od tri stvari:
    - dužine operanada
    - struktralnih hazarda
    - zavisnosti među podacima
- Konvoj: kad više instrukcija mogu da se izvršavaju istovremeno
    - Chaining: instrukcija počinje čim joj operandi postanu dostupni
    - Chime: dužina izvršavanja jednog konvoja
    - Računanje konvoja na osnovu latency

## Predikcija skoka
- Dvo-nivoski
    - Branch History Register: čuva se istorija skokova
    - History Pattern Table: tabela u kojoj se pamti automat stanja, adresiran preko BHR
    - Ako postoji više BHR, jedan može pamtiti ili za jedan skok ili grupu skokova, isto tako može postojati više PHT
- Korelacioni (M, N)
    - M širina globalnog BHR
    - N broj bitova automata stanja
    - BHR i PC adresiraju tabelu sa automatima stanja
- gshare
    - Jedna tabela adresirana heš funkcijom (XOR) BHR i PC
- tournament
    - Tri tabele, jedna adresirana preko BHR, druga preko PC, i treća da bira između te dve predikcije na osnovu PC
- Bimodal
    - Kao gshare ali ima tabela za često zadovoljen i često nezadovoljen uslov
- TAGE
    - Različite tabele u zavisnosti od toga kolika veličina istorije se gleda, pa selektor
- YAGS
    - Dva gshare prediktora za taken i not taken keš, i bimodal koji bira između njih
- gskew
    - Tri tabele, glasanje
    - e-gskew: Kao gskew samo je jedna tabela bimodal
    - 2bc-gskew: metaprediktor koji predviđa da li je bolji samo bimodal ili glasanje
- LVQ
- Perceptrons
- LTP
    - Predviđa samo kad će se završiti petlja
- BMP
    - Gleda na kojim petljama glavni prediktor radi loše i njih popravlja
- Meltdown
    - Flush and Reload: pristupamo `niz[zabranjeni_podatak]` i gledamo na kom mestu će biti keširano
- Spectre
    - Jedan program sadrži `array2[array1[x] * 4096]`, napadač zadaje `x` i može da izazove spekulativni buffer overflow
    - Zatrovati `jmp [rax]` tako da skoči na kod koji odaje sadržaj memorije
