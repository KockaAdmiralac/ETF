package rs.etf.pp1.syntax;

import rs.etf.pp1.ast.*;
import java_cup.runtime.Symbol;
import org.apache.log4j.Logger;

parser code {:
	public boolean errorDetected = false;
	private Logger logger = Logger.getLogger(getClass());

	public void report_fatal_error(String message, Object info) throws Exception {
		done_parsing();
		report_error(message, info);
	}

	public void syntax_error(Symbol cur_token) {
		report_error("Syntax error", cur_token);
	}

	public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
		report_fatal_error("Fatal error, parsing cannot continue", cur_token);
	}

	public void report_error(String message, Object info) {
		errorDetected = true;
		int errorOffset = 0;
		if (info instanceof Symbol) {
			errorOffset = ((Symbol)info).left;
		} else if (info instanceof Integer) {
			errorOffset = (int)info;
		}
		if (errorOffset == 0) {
			logger.error(message);
		} else {
			logger.error(message + " (line " + errorOffset + ")");
		}
	}
:}

terminal PROG, BREAK, CLASS, ELSE, CONST, IF, WHILE, NEW, PRINT, READ, RETURN, VOID, EXTENDS, CONTINUE, FOREACH, AND, OR, ASSIGN, SEMI, COMMA, PERIOD, LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE, LAMBDA;
terminal Boolean BOOL;
terminal Integer NUMBER;
terminal char CHARCONST;
terminal String IDENT;
terminal Integer ADDOP;
terminal Integer UADDOP;
terminal Integer MULOP;
terminal Integer RELOP;

nonterminal ConstDecl, Type, ConstDeclSingle, ConstDeclList, VarDecl, VarDeclSingle, VarDeclList, VarDeclMultiple, ClassMethodDecl, PreMainBlock, PreMainBlockList, MethodDeclList, ReturnType, FormPars, FormParamMultiple, FormParamSingle, StatementList, DesignatorStatement, ClassName, LoopHeader, IfHeader, ThenHeader, ElseHeader, Or;

nonterminal rs.etf.pp1.symboltable.concepts.Struct ArrayBrackets, Term, Factor, Expr, Condition, CondTerm, CondFact;
nonterminal rs.etf.pp1.symboltable.concepts.Obj Const, Program, ProgName, Designator, MethodName, MethodDecl, ConstructorType, ClassMethodBody, ClassDecl, Statement;
nonterminal rs.etf.pp1.semantics.ParameterList ActPars, FunctionCall;
nonterminal rs.etf.pp1.semantics.DesignatorList ArrayAssignmentDesignators;

precedence left ELSE;

Program ::= (Program) ProgName PreMainBlockList LBRACE MethodDeclList RBRACE;

ProgName ::= (ProgName) PROG IDENT:name;

ConstDecl ::= (ConstDecl) CONST Type ConstDeclList SEMI;

Const ::= (NumberConst) NUMBER:number | (CharConst) CHARCONST:charconst | (BoolConst) BOOL:bool;

Type ::= (Type) IDENT:typeName;

ConstDeclSingle ::= (ConstDeclSingle) IDENT:name ASSIGN Const;

ConstDeclList ::= (ListConstDeclList) ConstDeclSingle COMMA ConstDeclList
				| (ErrorListConstDeclList) error:s {: parser.report_error("Error during constant declaration, recovery until comma", sleft); :} COMMA ConstDeclList
				| (SingleConstDeclList) ConstDeclSingle
				| (ErrorSingleConstDeclList) error:s
				{: parser.report_error("Error during constant declaration, recovery until semicolon", sleft); :}
				;

VarDecl ::= (VarDecl) Type VarDeclList SEMI;

VarDeclSingle ::= (VarDeclSingle) IDENT:name ArrayBrackets;

VarDeclList ::= (ListVarDeclList) VarDeclSingle COMMA VarDeclList
			  | (ErrorListVarDeclList) error:s {: parser.report_error("Error during variable declaration, recovery until comma", sleft); :} COMMA VarDeclList
			  | (SingleVarDeclList) VarDeclSingle
			  | (ErrorSingleVarDeclList) error:s
			  {: parser.report_error("Error during variable declaration, recovery until semicolon", sleft); :}
			  ;

VarDeclMultiple ::= (ListVarDeclMultiple) VarDeclMultiple VarDecl | (EmptyVarDeclMultiple) /* empty */;

ArrayBrackets ::= (YesArrayBrackets) LBRACKET RBRACKET | (NoArrayBrackets) /* empty */;

ClassDecl ::= (RegularClassDecl) CLASS ClassName LBRACE VarDeclMultiple ClassMethodDecl RBRACE
			| (FieldErrorClassDecl) CLASS ClassName LBRACE error:s {: parser.report_error("Error in class field declaration, recovery until left brace", sleft); :} ClassMethodDecl RBRACE
			;

ClassMethodDecl ::= (BodyClassMethodDecl) LBRACE ClassMethodBody RBRACE | (EmptyClassMethodDecl) /* empty */;

ClassMethodBody ::= (ConstructorClassMethodBody) ClassMethodBody ConstructorType LPAREN FormPars RPAREN VarDeclMultiple LBRACE StatementList RBRACE
				  | (RegularClassMethodBody) ClassMethodBody MethodDecl
				  | (EmptyClassMethodBody) /* empty */
				  ;

ConstructorType ::= (ConstructorType) Type;

ClassName ::= (ExtendsClassName) IDENT:name EXTENDS IDENT:typeName
			| (ErrorExtendsClassName) IDENT EXTENDS error:s
			{: parser.report_error("Error in extends declaration, recovery until left brace", sleft); :}
			| (RegularClassName) IDENT:name
			;

PreMainBlock ::= (ConstDeclPreMainBlock) ConstDecl | (VarDeclPreMainBlock) VarDecl | (ClassDeclPreMainBlock) ClassDecl;

PreMainBlockList ::= (ListPreMainBlockList) PreMainBlockList PreMainBlock | (EmptyPreMainBlockList) /* empty */;

MethodDeclList ::= (ListMethodDeclList) MethodDeclList MethodDecl | (EmptyMethodDeclList) /* empty */;

MethodDecl ::= (MethodDecl) ReturnType MethodName LPAREN FormPars RPAREN VarDeclMultiple LBRACE StatementList RBRACE;

ReturnType ::= (VoidReturnType) VOID | (TypeReturnType) Type;

MethodName ::= (MethodName) IDENT:name;

FormPars ::= (MultipleFormPars) FormParamMultiple | (EmptyFormPars) /* empty */;

FormParamMultiple ::= (ListFormParamMultiple) FormParamSingle COMMA FormParamMultiple
					| (ErrorListFormParamMultiple) error:s {: parser.report_error("Error in formal parameters, recovery until comma", sleft); :} COMMA FormParamMultiple
					| (SingleFormParamMultiple) FormParamSingle
					| (ErrorSingleFormParamMultiple) error:s
					{: parser.report_error("Error in formal parameters, recovery until right brace", sleft); :}
					;

FormParamSingle ::= (FormParamSingle) Type IDENT:name ArrayBrackets;

Statement ::= (DesignatorStatementStatement) DesignatorStatement SEMI
			| (ErrorStatement) error:s SEMI
			{: parser.report_error("Error during assignment, recovery until semicolon", sleft); :}
			| (IfStatement) IF IfHeader LPAREN Condition RPAREN ThenHeader Statement
			| (IfElseStatement) IF IfHeader LPAREN Condition RPAREN ThenHeader Statement ELSE ElseHeader Statement
			| (WhileStatement) WHILE LoopHeader LPAREN Condition RPAREN ThenHeader Statement
			| (BreakStatement) BREAK SEMI
			| (ContinueStatement) CONTINUE SEMI
			| (ReturnNoExprStatement) RETURN SEMI
			| (ReturnExprStatement) RETURN Expr SEMI
			| (ReadStatement) READ LPAREN Designator RPAREN SEMI
			| (PrintNoNumberStatement) PRINT LPAREN Expr RPAREN SEMI
			| (PrintNumberStatement) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI
			| (ForeachStatement) Designator PERIOD FOREACH LoopHeader LPAREN IDENT:ident LAMBDA Statement RPAREN SEMI
			| (StatementListStatement) LBRACE StatementList RBRACE
			;

StatementList ::= (StatementStatementList) StatementList Statement | (EmptyStatementList) /* empty */;

LoopHeader ::= (LoopHeader) /* empty */;
IfHeader ::= (IfHeader) /* empty */;
ThenHeader ::= (ThenHeader) /* empty */;
ElseHeader ::= (ElseHeader) /* empty */;

DesignatorStatement ::= (AssignmentDesignatorStatement) Designator ASSIGN Expr
					  | (FunctionCallDesignatorStatement) Designator FunctionCall
					  | (UnaryAddopDesignatorStatement) Designator UADDOP:op
					  | (ArrayAssignmentDesignatorStatement) LBRACKET ArrayAssignmentDesignators RBRACKET ASSIGN Designator
					  ;

FunctionCall ::= (ActParsFunctionCall) LPAREN ActPars RPAREN | (NoParsFunctionCall) LPAREN RPAREN;

ArrayAssignmentDesignators ::= (EmptyArrayAssignmentDesignators) /* empty */
							 | (DesignatorArrayAssignmentDesignators) Designator
							 | (MissingListArrayAssignmentDesignators) ArrayAssignmentDesignators COMMA
							 | (DesignatorListArrayAssignmentDesignators) ArrayAssignmentDesignators COMMA Designator
							 ;

ActPars ::= (ExprActPars) Expr | (ExprListActPars) ActPars COMMA Expr;

Designator ::= (IdentDesignator) IDENT:symName
			 | (PropertyAccessDesignator) Designator PERIOD IDENT:fieldName
			 | (ArrayAccessDesignator) Designator LBRACKET Expr RBRACKET
			 ;

Expr ::= (TermExpr) Term
	   | (NegatedExpr) ADDOP Term
	   | (AddopExpr) Term ADDOP Expr
	   | (NegatedAddopExpr) ADDOP Term ADDOP Expr
	   ;

Term ::= (FactorTerm) Factor | (MulopTerm) Term MULOP Factor;

Factor ::= (DesignatorFactor) Designator
		 | (FunctionCallFactor) Designator FunctionCall
		 | (ConstFactor) Const
		 | (ArrayReferenceFactor) NEW Type LBRACKET Expr RBRACKET
		 | (ObjectReferenceFactor) NEW Type FunctionCall
		 | (ExpressionFactor) LPAREN Expr RPAREN
		 ;

Condition ::= (OrCondition) Condition Or CondTerm
			| (CondTermCondition) CondTerm
			| (ErrorCondition) error:s
			{: parser.report_error("Error in conditional expression, recovery until right brace", sleft); :}
			;

CondTerm ::= (AndCondTerm) CondTerm AND CondFact | (CondFactCondTerm) CondFact;

CondFact ::= (ExprCondFact) Expr | (RelopCondFact) Expr RELOP Expr;

Or ::= (Or) OR;
